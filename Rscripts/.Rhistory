options(osrm.server = "http://127.0.0.1:5000/")
distances <- osrmTable(src = branches_m_spdf, dst = branches_C_spdf)
distances <- osrmTable(src = branches_m_spdf, dst = branches_C_spdf)
# Once the local server is running:
options(osrm.server = "http://localhost:5000/")
distances <- osrmTable(src = branches_m_spdf, dst = branches_C_spdf)
# Use OSRM's server
options(osrm.server = "http://router.project-osrm.org/")
distances <- osrmTable(src = branches_m_spdf, dst = branches_C_spdf)
# Use OSRM's server
options(osrm.server = "http://router.project-osrm.org/")
distances <- osrmTable(src = branches_m_spdf, dst = branches_C_spdf)
# drawback: only allows matrix of times
str(distances) # a list with three elemnts:
# $durations is travel times,
# $sources is sources
# $destinations is travel times
distances$durations %>% head()
# NOTE: above uses OSRM's server. If we try one with more than 10,000 queries:
#  (now we are calculating distance from 110 treatment to all 506 branches, 56k queries)
distances <- osrmTable(src = branches_m_spdf, dst = branches_spdf)
# Once the local server is running:
options(osrm.server = "http://localhost:5000/")
# NOTE: above uses OSRM's server. If we try one with more than 10,000 queries:
#  (now we are calculating distance from 110 treatment to all 506 branches, 56k queries)
distances <- osrmTable(src = branches_m_spdf, dst = branches_spdf)
# NOTE: above uses OSRM's server. If we try one with more than 10,000 queries:
#  (now we are calculating distance from 110 treatment to all 506 branches, 56k queries)
distances <- osrmTable(src = branches_m_spdf, dst = branches_spdf)
# Once the local server is running:
options(osrm.server = "http://localhost:5000/")
distances <- osrmTable(src = branches_m_spdf, dst = branches_C_spdf)
# Once the local server is running:
options(osrm.server = "http://localhost:5000/")
distances <- osrmTable(src = branches_m_spdf, dst = branches_C_spdf)
# NOTE: above uses OSRM's server. If we try one with more than 10,000 queries:
#  (now we are calculating distance from 110 treatment to all 506 branches, 56k queries)
distances <- osrmTable(src = branches_m_spdf, dst = branches_spdf)
# NOTE: above uses OSRM's server. If we try one with more than 10,000 queries:
#  (now we are calculating distance from 110 treatment to all 506 branches, 56k queries)
distances <- osrmTable(src = branches_m_spdf, dst = branches_spdf)
# NOTE: above uses OSRM's server. If we try one with more than 10,000 queries:
#  (now we are calculating distance from 110 treatment to all 506 branches, 56k queries)
distances <- osrmTable(src = branches_m_spdf, dst = branches_spdf)
distances <- osrmTable(src = branches_m_spdf, dst = branches_C_spdf)
# Once the local server is running:
options(osrm.server = "http://localhost:5000/")
distances <- osrmTable(src = branches_m_spdf, dst = branches_C_spdf)
# NOTE: above uses OSRM's server. If we try one with more than 10,000 queries:
#  (now we are calculating distance from 110 treatment to all 506 branches, 56k queries)
distances <- osrmTable(src = branches_m_spdf, dst = branches_spdf)
# Once the local server is running:
options(osrm.server = "http://localhost:5000/")
distances <- osrmTable(src = branches_m_spdf, dst = branches_C_spdf)
# NOTE: above uses OSRM's server. If we try one with more than 10,000 queries:
#  (now we are calculating distance from 110 treatment to all 506 branches, 56k queries)
distances <- osrmTable(src = branches_m_spdf, dst = branches_spdf)
# drawback: only allows matrix of times
str(distances) # a list with three elemnts:
# $durations is travel times,
# $sources is sources
# $destinations is travel times
distances$durations %>% head()
branches <- read_sf(here::here("data","shapefiles","bansefi_geocoordinates")) %>%
st_transform(4326) %>%  # longlat
rename(sucursal = SUCURSALES)
# PACKAGES
library(tidyverse) # data wrangling
library(stringr)   # work with strings
library(sf)        # geospatial
library(geosphere) # calculate distances
library(haven)     # read/write .dta (Stata)
library(here)      # use relative filepaths
library(osrm)      # calculate road distances
library(assertthat)
# old spatial packages since osrm works with those
library(sp) #spatial objects; used by rgdal
# Attempt with Google Maps API
# library(gmapsdistance)
#  Annoying about gmapsdistance: requires loc to already be in string format;
#   format of output is annoying
# gmapsdistance(origin = "22.395166,-97.935361", destination = "19.4144735,-99.160476",
#   mode = "walking"
# )
branches <- read_sf(here::here("data","shapefiles","bansefi_geocoordinates")) %>%
st_transform(4326) %>%  # longlat
rename(sucursal = SUCURSALES)
View(branches)
# Read in data set indicate which branches are in experiment and their treatment assignment
branches_RCT = read_dta(here::here("proc", "branches.dta")) %>%
mutate(sucursal = as.integer(sucursal))
# branches<-read_sf("~/")
# Make variable names lowercase
names(branches) <- map(names(branches), str_to_lower)
# One Bansefi branch is missing geometry:
branches %>% filter(sucursal == 842) # missing
# Manually get it using address on Google Maps:
sucursal_842 <- st_sf(
sucursal = 842,
geometry = st_sfc(st_point(c(-97.935361, 22.395166)))
) %>%
st_set_crs(4326) # because the point was taken from Google Maps coordinates
# Then merge it in
branches <- branches %>%
filter(sucursal!=842) %>% # in experiment
arrange(sucursal) %>%
select(sucursal, geometry)
nrow(branches) #505
branches <- rbind(branches, sucursal_842)
# Read in data set indicate which branches are in experiment and their treatment assignment
branches_RCT = read_dta(here::here("proc", "branches.dta")) %>%
mutate(sucursal = as.integer(sucursal))
names(branches_RCT) <- map(names(branches_RCT), str_to_lower)
branches_m <- right_join(branches, branches_RCT,
by = "sucursal"
) # full join so it remains a sf object
# Convert to SpatialPointsDataFrame for use with osrmTable
branches_spdf <- branches %>% as('Spatial')
View(branches_spdf)
View(branches_spdf)
View(branches_spdf)
# Use OSRM's server
options(osrm.server = "http://router.project-osrm.org/")
distances <- osrmTable(src = branches_m_spdf, dst = branches_C_spdf)
bansefi.coordinates = here::here("data", "shapefiles", "bansefi_geocoordinates")
state.polygons = here::here("data", "shapefiles", "state_polygons")
df.locality.polygons = here::here("data", "shapefiles", "df_locality_polygons")
############
# PACKAGES #
############
source(here::here("scripts","load_packages.R"))
#############
# FUNCTIONS #
#############
source(here::here("scripts","myfunctions.R"))
##########
# LOCALS #
##########
eps = 1
png = 0
########
# DATA #
########
# Read in Bansefi branch coordinates
branches = read_sf(bansefi.coordinates,"suc_bansefi_2008ccl") %>%
st_transform(4326) # longlat
class(branches) # "sf"
head(branches)
# Read in state polygons, convert to lat/long
states = read_sf(state.polygons,"estatal") %>%
st_transform(4326) # longlat
head(states)
# Read in Mexico City locality polygons, convert to lat/long
df = read_sf(df.locality.polygons,"df_loc_urb") %>%
st_transform(4326) # longlat
head(df)
# Read in data on branches included in RCT, merge with geocoordinates
branches.RCT    = read_dta(here::here("proc", "branches.dta")) %>%
mutate(sucursal = as.integer(sucursal))
head(branches.RCT)
branches.merged <- left_join(branches, branches.RCT,
by = c("SUCURSALES" = "sucursal")
) %>%
arrange(SUCURSALES) %>%
select(SUCURSALES, everything())
sum(!(is.na(branches.merged$tratamiento))) # 109, missing one
branches.merged %>% tab(tratamiento)
head(branches.merged)
# Colors of treatment and control
branches.merged <- branches.merged %>%
mutate(mycolor = ifelse(
tratamiento == 0, "orange", "blue")) # note will be NA if is.na(tratamiento)
branches.merged %>% tab(mycolor)
#########
# GRAPH #
#########
# NATIONAL LEVEL #
# Randomly order data frame
set.seed(20171218)
branches.merged <- branches.merged %>%
mutate(random = runif(nrow(branches.merged))) %>%
arrange(random)
branches.TorC <- branches.merged %>%
filter(!(is.na(branches.merged$tratamiento)))
nrow(branches.TorC) # 109
names(branches.TorC)
# Graph all branches
#  problem: in Mexico city they're all orange on top; wasn't occuring in branches_geocoordinates.R
ggplot() +
geom_sf(data = states, color = "black", fill = "white") +
geom_sf(data = branches.TorC, aes(color = mycolor)) +
scale_color_manual(values = c("blue", "orange"),
labels = c("orange" = "Control", "blue" = "Treatment")
) +
theme_tufte(base_family = "sans") +
theme(legend.position = "none",
# axis.text = element_blank(),
axis.ticks = element_blank(),
axis.line = element_blank(),
panel.border = element_blank(),
panel.grid.major = element_line(colour = "white"), # due to bug, http://bit.ly/2AWhuVt
panel.grid.minor = element_blank()
) +
# Manual legend:
annotate(geom = "point", x = -95.5, y = 30, size = 1.5, color = "blue") +
annotate(geom = "text", x = -95, y = 30, label = "Treatment",
size = 3.5, hjust = 0, vjust = 0.5) +
annotate(geom = "point", x = -95.5, y = 29, size = 1.5, color = "orange") +
annotate(geom = "text", x = -95, y = 29, label = "Control",
size = 3.5, hjust = 0, vjust = 0.5) +
labs(x = "", y = "")
# CALCULATE DISTANCE BETWEEN TREATMENT AND CONTROL BRANCHES
#  Test out some different distance or time functions:
#   osrmTable, gmapsdistance
# PACKAGES
library(tidyverse) # data wrangling
library(stringr)   # work with strings
library(sf)        # geospatial
library(geosphere) # calculate distances
library(haven)     # read/write .dta (Stata)
library(here)      # use relative filepaths
library(osrm)      # calculate road distances
library(assertthat)
# old spatial packages since osrm works with those
library(sp) #spatial objects; used by rgdal
# Attempt with Google Maps API
# library(gmapsdistance)
#  Annoying about gmapsdistance: requires loc to already be in string format;
#   format of output is annoying
# gmapsdistance(origin = "22.395166,-97.935361", destination = "19.4144735,-99.160476",
#   mode = "walking"
# )
branches <- read_sf(here::here("data","shapefiles","bansefi_geocoordinates")) %>%
st_transform(4326) %>%  # longlat
rename(sucursal = SUCURSALES)
# branches<-read_sf("~/")
# Make variable names lowercase
names(branches) <- map(names(branches), str_to_lower)
# One Bansefi branch is missing geometry:
branches %>% filter(sucursal == 842) # missing
# Manually get it using address on Google Maps:
sucursal_842 <- st_sf(
sucursal = 842,
geometry = st_sfc(st_point(c(-97.935361, 22.395166)))
) %>%
st_set_crs(4326) # because the point was taken from Google Maps coordinates
# Then merge it in
branches <- branches %>%
filter(sucursal!=842) %>% # in experiment
arrange(sucursal) %>%
select(sucursal, geometry)
nrow(branches) #505
branches <- rbind(branches, sucursal_842)
# Read in data set indicate which branches are in experiment and their treatment assignment
branches_RCT = read_dta(here::here("proc", "br.dta")) %>%
mutate(sucursal = as.integer(sucursal))
names(branches_RCT) <- map(names(branches_RCT), str_to_lower)
branches_m <- right_join(branches, branches_RCT,
by = "sucursal"
) # full join so it remains a sf object
assert_that(nrow(branches_m) == 110) # 110, so above worked
branches_C <- branches_m[which(branches_m$tratamiento == 0), ]
assert_that(branches_C %>% nrow() == 70)
# Convert to SpatialPointsDataFrame for use with osrmTable
branches_spdf <- branches %>% as('Spatial')
branches_m_spdf <- branches_m %>% as('Spatial')
branches_C_spdf <- branches_C %>% as('Spatial')
# Use OSRM's server
options(osrm.server = "http://router.project-osrm.org/")
distances <- osrmTable(src = branches_m_spdf, dst = branches_C_spdf)
# drawback: only allows matrix of times
str(distances) # a list with three elemnts:
# $durations is travel times,
# $sources is sources
# $destinations is travel times
distances$durations %>% head()
View(branches_C)
View(branches_m_spdf)
View(distances)
branches <- read_sf(here::here("data","shapefiles","bansefi_geocoordinates")) %>%
st_transform(4326) %>%  # longlat
rename(sucursal = SUCURSALES)
# branches<-read_sf("~/")
# Make variable names lowercase
names(branches) <- map(names(branches), str_to_lower)
# One Bansefi branch is missing geometry:
branches %>% filter(sucursal == 842) # missing
# Manually get it using address on Google Maps:
sucursal_842 <- st_sf(
sucursal = 842,
geometry = st_sfc(st_point(c(-97.935361, 22.395166)))
) %>%
st_set_crs(4326) # because the point was taken from Google Maps coordinates
# Then merge it in
branches <- branches %>%
filter(sucursal!=842) %>% # in experiment
arrange(sucursal) %>%
select(sucursal, geometry)
nrow(branches) #505
branches <- rbind(branches, sucursal_842)
# Read in data set indicate which branches are in experiment and their treatment assignment
branches_RCT = read_dta(here::here("proc", "br.dta")) %>%
mutate(sucursal = as.integer(sucursal))
names(branches_RCT) <- map(names(branches_RCT), str_to_lower)
branches_m <- right_join(branches, branches_RCT,
by = "sucursal"
) # full join so it remains a sf object
assert_that(nrow(branches_m) == 110) # 110, so above worked
branches_C <- branches_m[which(branches_m$tratamiento == 0), ]
assert_that(branches_C %>% nrow() == 70)
# Convert to SpatialPointsDataFrame for use with osrmTable
branches_spdf <- branches %>% as('Spatial')
branches_m_spdf <- branches_m %>% as('Spatial')
branches_C_spdf <- branches_C %>% as('Spatial')
# Use OSRM's server
options(osrm.server = "http://router.project-osrm.org/")
distances <- osrmTable(src = branches_m_spdf, dst = branches_C_spdf)
# drawback: only allows matrix of times
str(distances) # a list with three elemnts:
# $durations is travel times,
# $sources is sources
# $destinations is travel times
distances$durations %>% head()
distances$durations
View(distances)
# CALCULATE DISTANCE BETWEEN TREATMENT AND CONTROL BRANCHES
#  Test out some different distance or time functions:
#   osrmTable, gmapsdistance
# PACKAGES
library(tidyverse) # data wrangling
library(stringr)   # work with strings
library(sf)        # geospatial
library(geosphere) # calculate distances
library(haven)     # read/write .dta (Stata)
library(here)      # use relative filepaths
library(osrm)      # calculate road distances
library(assertthat)
# old spatial packages since osrm works with those
library(sp) #spatial objects; used by rgdal
# Attempt with Google Maps API
# library(gmapsdistance)
#  Annoying about gmapsdistance: requires loc to already be in string format;
#   format of output is annoying
# gmapsdistance(origin = "22.395166,-97.935361", destination = "19.4144735,-99.160476",
#   mode = "walking"
# )
branches <- read_sf(here::here("data","shapefiles","bansefi_geocoordinates")) %>%
st_transform(4326) %>%  # longlat
rename(sucursal = SUCURSALES)
View(branches)
# Convert to SpatialPointsDataFrame for use with osrmTable
branches_spdf <- branches %>% as('Spatial')
View(branches_spdf)
View(branches)
View(branches)
# PACKAGES
library(tidyverse) # data wrangling
library(stringr)   # work with strings
library(sf)        # geospatial
library(geosphere) # calculate distances
library(haven)     # read/write .dta (Stata)
library(here)      # use relative filepaths
library(osrm)      # calculate road distances
library(assertthat)
# Once the local server is running:
options(osrm.server = "http://localhost:5000/")
distances <- osrmTable(src = branches_m_spdf, dst = branches_C_spdf)
# PACKAGES
library(tidyverse) # data wrangling
library(stringr)   # work with strings
library(sf)        # geospatial
library(geosphere) # calculate distances
library(haven)     # read/write .dta (Stata)
library(here)      # use relative filepaths
library(osrm)      # calculate road distances
library(assertthat)
# old spatial packages since osrm works with those
library(sp) #spatial objects; used by rgdal
# Attempt with Google Maps API
# library(gmapsdistance)
#  Annoying about gmapsdistance: requires loc to already be in string format;
#   format of output is annoying
# gmapsdistance(origin = "22.395166,-97.935361", destination = "19.4144735,-99.160476",
#   mode = "walking"
# )
branches <- read_sf(here::here("data","shapefiles","bansefi_geocoordinates")) %>%
st_transform(4326) %>%  # longlat
rename(sucursal = SUCURSALES)
# branches<-read_sf("~/")
# Make variable names lowercase
names(branches) <- map(names(branches), str_to_lower)
# One Bansefi branch is missing geometry:
branches %>% filter(sucursal == 842) # missing
# Manually get it using address on Google Maps:
sucursal_842 <- st_sf(
sucursal = 842,
geometry = st_sfc(st_point(c(-97.935361, 22.395166)))
) %>%
st_set_crs(4326) # because the point was taken from Google Maps coordinates
# Then merge it in
branches <- branches %>%
filter(sucursal!=842) %>% # in experiment
arrange(sucursal) %>%
select(sucursal, geometry)
nrow(branches) #505
branches <- rbind(branches, sucursal_842)
# Read in data set indicate which branches are in experiment and their treatment assignment
branches_RCT = read_dta(here::here("proc", "br.dta")) %>%
mutate(sucursal = as.integer(sucursal))
names(branches_RCT) <- map(names(branches_RCT), str_to_lower)
branches_m <- right_join(branches, branches_RCT,
by = "sucursal"
) # full join so it remains a sf object
assert_that(nrow(branches_m) == 110) # 110, so above worked
branches_C <- branches_m[which(branches_m$tratamiento == 0), ]
assert_that(branches_C %>% nrow() == 70)
# Convert to SpatialPointsDataFrame for use with osrmTable
branches_spdf <- branches %>% as('Spatial')
branches_m_spdf <- branches_m %>% as('Spatial')
branches_C_spdf <- branches_C %>% as('Spatial')
# Use OSRM's server
options(osrm.server = "http://router.project-osrm.org/")
distances <- osrmTable(src = branches_m_spdf, dst = branches_C_spdf)
# drawback: only allows matrix of times
str(distances) # a list with three elemnts:
# $durations is travel times,
# $sources is sources
# $destinations is travel times
distances$durations %>% head()
# NOTE: above uses OSRM's server. If we try one with more than 10,000 queries:
#  (now we are calculating distance from 110 treatment to all 506 branches, 56k queries)
distances <- osrmTable(src = branches_m_spdf, dst = branches_spdf)
# We get the error:
# OSRM returned an error:
# Error: The public OSRM API does not allow results with a number of durations
# higher than 10000. Ask for fewer durations or use your own server and set its
# --max-table-size option.
# Now try it on a local server to avoid the 10,000 query limit:
# First follow the instructions here to install and build the OSRM server:
# https://datawookie.netlify.com/blog/2017/09/building-a-local-osrm-instance/
# or:
# https://github.com/Project-OSRM/osrm-backend/wiki/Running-OSRM
# Now in a terminal, change to the folder containing the .osrm file and run:
#  osrm-routed mexico-latest.osrm
# Once the local server is running:
options(osrm.server = "http://localhost:5000/")
distances <- osrmTable(src = branches_m_spdf, dst = branches_C_spdf)
distances <- osrmTable(src = branches_m_spdf, dst = branches_C_spdf)
View(distances)
distances[["durations"]]
(g
#load ggmap
library(httr)
library(ggmap)
library(ggplot2)
library(tidyverse)
library(devtools)
library(osrm)
# PACKAGES
library(tidyverse) # data wrangling
library(stringr)   # work with strings
library(sf)        # geospatial
library(geosphere) # calculate distances
library(haven)     # read/write .dta (Stata)
library(here)      # use relative filepaths
library(osrm)      # calculate road distances
library(assertthat)
# old spatial packages since osrm works with those
library(sp) #spatial objects; used by rgdal
setwd('C:/Users/xps-seira/Dropbox/Apps/ShareLaTeX/metodos_estadisticos/Rscripts')
geocoded <- read.csv('../DB/geocoded_p2.csv', stringsAsFactors = FALSE) %>%
drop_na()
geocoded_sp <- st_as_sf(geocoded ,coords = c("lon","lat"),crs=4326, sf_column_name="geometry") %>%
as('Spatial')
# Use OSRM's server
# options(osrm.server = "http://router.project-osrm.org/")
# Use local instance
options(osrm.server = "http://localhost:5000/")
for(i in 1:nrow(geocoded)) {
tryCatch({
result <- osrmRoute(src = geocoded[i,c("folio","lon","lat")], dst = jlca, overview= FALSE)
geocoded$duration[i] <- as.numeric(result[1])
geocoded$distance[i] <- as.numeric(result[2])
}, error=function(e){})
}
# Manually get it using address on Google Maps:
jlca <- st_sf(
folio = "0000-0000" ,
demandado = 0,
addresses = "Av. Dr. Río de la Loza 68, Doctores, 06720 Ciudad de México, CDMX, Mexico",
geoAddress= "Av. Dr. Río de la Loza 68, Doctores, 06720 Ciudad de México, CDMX, Mexico",
geometry = st_sfc(st_point(c(-99.14541650000001, 19.4245109)))
) %>%
st_set_crs(4326) %>% # because the point was taken from Google Maps coordinates
mutate(folio = as.character(folio),
addresses = as.character(addresses),
geoAddress = as.character(geoAddress)
) %>%
as('Spatial')
# Use OSRM's server
# options(osrm.server = "http://router.project-osrm.org/")
# Use local instance
options(osrm.server = "http://localhost:5000/")
for(i in 1:nrow(geocoded)) {
tryCatch({
result <- osrmRoute(src = geocoded[i,c("folio","lon","lat")], dst = jlca, overview= FALSE)
geocoded$duration[i] <- as.numeric(result[1])
geocoded$distance[i] <- as.numeric(result[2])
}, error=function(e){})
}
osrmRoute(src = geocoded[i,c("folio","lon","lat")], dst = jlca, overview= FALSE)
i
